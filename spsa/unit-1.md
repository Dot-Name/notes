# Evolution of Components Systems Programming

- [Compiler](https://github.com/iamharshdabas/notes/blob/master/spsa/unit-1.md#compiler)
- [Assembler](https://github.com/iamharshdabas/notes/blob/master/spsa/unit-1.md#assembler)

## Compiler

A compiler is a software tool that translates high-level programming code into low-level machine code that can be executed by a computer. It performs this translation in several distinct phases. Here are the key points to understand about the compilation process:

1. **Lexical Analysis**: This is the first phase of the compiler. It involves scanning the source code and breaking it down into tokens, which are meaningful units of the programming language. The lexical analyzer, also known as the scanner, reads the characters from the source program and groups them into lexemes (sequences of characters that "go together"). Each lexeme corresponds to a token. Tokens are defined by regular expressions that are understood by the lexical analyzer. The lexical analyzer also removes lexical errors, comments, and whitespace.

2. **Syntax Analysis**: The second phase of the compiler is syntax analysis, also known as parsing. In this phase, the compiler checks whether the sequence of tokens generated by the lexical analyzer follows the rules of the programming language's grammar. It builds a parse tree or an abstract syntax tree (AST) to represent the structure of the program. The parse tree/AST helps in further analysis and code generation.

3. **Semantic Analysis**: Once the syntax has been analyzed, the compiler performs semantic analysis. This phase checks whether the components of the source program are meaningful or not. It verifies that the program adheres to the semantic rules of the programming language. Semantic analysis includes type checking, scope resolution, and other checks to ensure that the program is semantically correct.

4. **Intermediate Code Generation**: After the semantic analysis, the compiler generates an intermediate representation of the source code. This intermediate code is a lower-level representation of the program that is easier to analyze and optimize. It serves as a bridge between the high-level source code and the target machine code. There are different forms of intermediate code, such as three-address code, abstract syntax trees, or bytecode.

5. **Optimization**: The next phase is optimization, where the compiler applies various techniques to improve the performance of the generated machine code. Optimization aims to reduce the execution time, memory usage, and other resources required by the program. It analyzes the intermediate code and applies transformations to make the code more efficient while preserving its functionality.

6. **Code Generation**: The final phase of the compilation process is code generation. In this phase, the compiler takes the optimized intermediate code and generates the actual machine code that can be executed by the target hardware. The code generator translates the intermediate code into a sequence of machine instructions that perform the same tasks as the original program. The generated code should have the same meaning as the source code and be efficient in terms of memory and CPU resource usage.

To summarize, the steps required for compilation are:

1. Lexical Analysis: Break down the source code into tokens.
2. Syntax Analysis: Check the sequence of tokens for adherence to the programming language's grammar.
3. Semantic Analysis: Verify the meaning and correctness of the program.
4. Intermediate Code Generation: Create an intermediate representation of the program.
5. Optimization: Apply transformations to improve the performance of the code.
6. Code Generation: Translate the optimized intermediate code into machine code.

These steps are performed in a sequential manner, with each phase taking input from the previous phase and producing output for the next phase. The compiler's goal is to produce an executable program that behaves correctly and efficiently on the target hardware.

## Assembler

An assembler is a type of computer program that takes in basic instructions and converts them into a pattern of bits that the computer's processor can use to perform basic operations. The assembler's job is to convert assembler or assembly language code into machine code that the computer can then read and execute.

### Types of assemblers

Assembler programs bridge the gap between assembly language and machine language that the computer's processor and memory can read. The assembler type is defined by the number of times it takes the program to scan the source code to translate it into machine language. There are two main types of assemblers.

1. Single Phase Assembler:

   - A single-phase assembler performs all the tasks in a single pass over the assembly code.
   - It reads each line of code, analyzes it, and generates the corresponding machine code.
   - It resolves forward references by using a symbol table.
   - It is simple and efficient for small programs but may not handle complex programs efficiently.

2. Two Phase Assembler:

   - A two-phase assembler divides the assembly process into two passes: analysis and synthesis.
   - In the analysis phase:
     - It separates the label, mnemonic opcode, and operand fields of each statement.
     - It enters the symbol and its corresponding location counter value into the symbol table.
     - It checks the validity of the mnemonic opcode using the mnemonics table.
     - It updates the location counter based on the opcode and operands.
   - In the synthesis phase:
     - It obtains the machine opcode corresponding to the mnemonic from the mnemonics table.
     - It obtains the address of each memory operand from the symbol table.
     - It synthesizes a machine instruction or the correct representation of a constant.
   - The two-phase approach allows the assembler to handle forward references efficiently.

### Problem Statement

- The assembler analyzes the assembly code and generates the corresponding machine code instructions.
- It resolves memory requirements for each assembly statement.
- It constructs the symbol table, which associates labels with memory addresses.

### Symbol Table

- The symbol table is a data structure used by the assembler to associate labels with memory addresses.
- It is constructed during the analysis phase and used during the synthesis phase.
- Each entry in the symbol table consists of a symbol (label) and its corresponding memory address.
- The symbol table allows the assembler to resolve forward references and generate correct machine code.
- It promotes self-documenting code by allowing instructions to reference memory locations by name.

### How assemblers work

Most computers come with a basic set of instructions called assembler instructions that correspond to the basic machine operations that the computer can perform. For example, a load instruction causes the processor to move a string of bits from a location in the processor to a special holding place called a register.

A programmer uses a sequence of these assembler instructions to write the source code. The assembler program then takes each statement in the source program and generates a corresponding bit stream or pattern called the object code. This output remains relative to the input source program and can then be executed as needed. The bit stream that constitutes the object program is called the machine code.

The assembler identifies the symbolic names associated with each instruction and allocates memory to each instruction. It also maintains a program counter or location counter (LC) to keep track of the memory addresses of every instruction. As it processes these instructions, it updates the LC and generates the target machine code.

## What is a text editor?
A text editor refers to any form of computer program that enables users to create, change, edit, open and view plain text files. They come already installed on most operating systems but their dominant application has evolved from notetaking and creating documents to crafting complex code. Today, text editors are a core part of a developer’s toolbox and are most commonly used to create computer programmes, edit hypertext markup language (HTML), and build and design web pages.

Examples of commonly used text editors include:

- Android Studio
- Atom
- Notepad++
- Sublime Text
- VS Code
### Features and functions of a text editor
1. Syntax highlighting:
Reading through endless reams of code can be overwhelming and time-consuming – not to mention messy. This feature allows users to colour code text based on the programming or markup language it is written in (such as HTML and Javascript) for ease of reference.

2. Intelligent code completion:
A context-aware software that speeds up the coding process by reducing typos, correcting common mistakes and offering auto-completion suggestions for syntax errors.

3. Snippets:
An essential feature that enables users to quickly substitute longer pieces of content or code with a shortcut phrase – which is great for creating forms, formatting articles or replicating chunks of information that you’re likely to repeat in your day-to-day workload.

4. Code folding:
Also called expand and collapse, the code folding feature hides or displays certain sections of code or text, allowing for a streamlined and decluttered display – great for if you’re working on a long document.

5. Vertical selection editing:
A useful tool that enables users to select, edit or add to multiple lines of code simultaneously, which is great for making repeat small changes (such as adding the same character to the end of every line, or deleting recurring errors).












